package controllers

import (
	"context"
	"math/rand"
	"strings"
	"time"

	. "github.com/onsi/ginkgo"
	. "github.com/onsi/gomega"

	v1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/errors"
	//"k8s.io/apimachinery/pkg/api/resource"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"

	batchv1 "k8s.io/api/batch/v1"
	batchv1beta1 "k8s.io/api/batch/v1beta1"

	pscv1alpha1 "cronprimer.local/api/v1alpha1"
)

var namespace = "psc-system"
var namePrefix = "psc-test-local-"
var autogenPrefix = "autogen-"

var _ = Describe("PrescaledCronJob Controller", func() {

	const timeout = time.Second * 60
	const interval = time.Second * 1

	ctx := context.Background()

	BeforeEach(func() {
		// failed test runs that don't clean up leave resources behind.
	})

	AfterEach(func() {

	})

	// Add Tests for OpenAPI validation (or additional CRD features) specified in
	// your API definition.
	// Avoid adding tests for vanilla CRUD operations because they would
	// test Kubernetes API server, which isn't the goal here.
	Context("Cronjob Autogeneration", func() {
		It("Should create cronjob correctly", func() {

			// construct a prescaled cron in code + post to K8s
			toCreate := generatePSCSpec()
			autogenName := autogenPrefix + toCreate.Name

			Expect(k8sClient.Create(ctx, &toCreate)).Should(Succeed())
			time.Sleep(time.Second * 5)

			fetched := &pscv1alpha1.PreScaledCronJob{}
			fetchedAutogenCron := &batchv1beta1.CronJob{}

			// check the CRD was created ok
			Eventually(func() bool {
				err := k8sClient.Get(ctx, types.NamespacedName{Name: toCreate.Name, Namespace: namespace}, fetched)
				return err == nil
			}, timeout, interval).Should(BeTrue())

			// get + compare the autogenerated cronjob
			Eventually(func() bool {
				err := k8sClient.Get(ctx, types.NamespacedName{Name: autogenName, Namespace: namespace}, fetchedAutogenCron)
				return err == nil
			}, timeout, interval).Should(BeTrue())

			// test the cronjob props
			Expect(len(fetchedAutogenCron.Spec.JobTemplate.Spec.Template.Spec.InitContainers)).To(Equal(1))
			Expect(fetchedAutogenCron.Spec.JobTemplate.Spec.Template.Spec.InitContainers[0].Name).To(Equal(warmupContainerInjectNameUID))
			Expect(fetchedAutogenCron.Name).To(Equal(autogenName))
			Expect(fetchedAutogenCron.Spec.Schedule).To(Equal("20 * * 10 *"))
			Expect(len(fetchedAutogenCron.Spec.JobTemplate.Spec.Template.Spec.InitContainers)).To(Equal(1))
			Expect(fetchedAutogenCron.OwnerReferences[0].UID).To(Equal(fetched.UID))
		})
	})

	It("Should update the CRD and cronjob correctly", func() {

		toCreate := generatePSCSpec()
		autogenName := autogenPrefix + toCreate.Name
		Expect(k8sClient.Create(ctx, &toCreate)).Should(Succeed())
		time.Sleep(time.Second * 5)

		original := &pscv1alpha1.PreScaledCronJob{}
		Expect(k8sClient.Get(ctx, types.NamespacedName{Name: toCreate.Name, Namespace: namespace}, original)).Should(Succeed())
		original.Spec.CronJob.Spec.Schedule = "30 * * 10 *"
		original.Spec.WarmUpTimeMins = 1

		Expect(k8sClient.Update(ctx, original)).Should(Succeed())
		time.Sleep(time.Second * 10)

		fetched := &pscv1alpha1.PreScaledCronJob{}
		fetchedAutogenCron := &batchv1beta1.CronJob{}

		// check the CRD was updated ok
		Eventually(func() bool {
			err := k8sClient.Get(ctx, types.NamespacedName{Name: toCreate.Name, Namespace: namespace}, fetched)
			return err == nil
		}, timeout, interval).Should(BeTrue())

		// check the custom CRD schedule has updated
		Expect(fetched.Spec.CronJob.Spec.Schedule).To(Equal("30 * * 10 *"))
		Expect(fetched.Spec.WarmUpTimeMins).To(Equal(1))

		// get + compare the autogenerated cronjob
		Eventually(func() bool {
			err := k8sClient.Get(ctx, types.NamespacedName{Name: autogenName, Namespace: namespace}, fetchedAutogenCron)
			return err == nil
		}, timeout, interval).Should(BeTrue())

		// check the autogenerated cronjob has been updated
		Expect(fetchedAutogenCron.Spec.Schedule).To(Equal("29 * * 10 *"))
	})

	It("Should delete the CRD and autogenerated cronjob", func() {

		toCreate := generatePSCSpec()
		autogenName := autogenPrefix + toCreate.Name
		Expect(k8sClient.Create(ctx, &toCreate)).Should(Succeed())
		time.Sleep(time.Second * 5)

		original := &pscv1alpha1.PreScaledCronJob{}
		Expect(k8sClient.Get(ctx, types.NamespacedName{Name: toCreate.Name, Namespace: namespace}, original)).Should(Succeed())

		By("Deleting the prescaled cron job CRD")
		Expect(k8sClient.Delete(ctx, original)).Should(Succeed())
		time.Sleep(time.Second * 15)

		// check the psc has gone
		Eventually(func() bool {
			fetched := &pscv1alpha1.PreScaledCronJob{}
			err := k8sClient.Get(ctx, types.NamespacedName{Name: toCreate.Name, Namespace: namespace}, fetched)
			return errors.IsNotFound(err)
		}, timeout, interval).Should(BeTrue())

		Eventually(func() bool {
			fetchedAutogenCron := &batchv1beta1.CronJob{}
			err := k8sClient.Get(ctx, types.NamespacedName{Name: autogenName, Namespace: namespace}, fetchedAutogenCron)
			return errors.IsNotFound(err)
		}, timeout, interval).Should(BeTrue())

	})

	It("Should add the warmup initContainer as the first item in initContainers", func() {

		// construct a prescaled cron in code  post to K8s
		toCreate := generatePSCSpec()
		autogenName := autogenPrefix + toCreate.Name
		toCreate.Spec.CronJob.Spec.JobTemplate.Spec.Template.Spec.InitContainers =
			[]v1.Container{
				{
					Image: "busybox",
					Name:  "iatric",
					Args: []string{
						"/bin/sh",
						"-c",
						"date",
					},
				},
			}

		By("Creating the prescaled cron job CRD")
		Expect(k8sClient.Create(ctx, &toCreate)).Should(Succeed())
		time.Sleep(time.Second * 5)

		fetched := &pscv1alpha1.PreScaledCronJob{}
		fetchedAutogenCron := &batchv1beta1.CronJob{}

		// check the CRD was created ok
		Eventually(func() bool {
			err := k8sClient.Get(ctx, types.NamespacedName{Name: toCreate.Name, Namespace: namespace}, fetched)
			return err == nil
		}, timeout, interval).Should(BeTrue())

		// get  compare the autogenerated cronjob
		Eventually(func() bool {
			err := k8sClient.Get(ctx, types.NamespacedName{Name: autogenName, Namespace: namespace}, fetchedAutogenCron)
			return err == nil
		}, timeout, interval).Should(BeTrue())

		// test the cronjob props
		Expect(len(fetchedAutogenCron.Spec.JobTemplate.Spec.Template.Spec.InitContainers)).To(Equal(2))
		Expect(fetchedAutogenCron.Spec.JobTemplate.Spec.Template.Spec.InitContainers[0].Name).To(Equal(warmupContainerInjectNameUID))
		Expect(fetchedAutogenCron.Spec.JobTemplate.Spec.Template.Spec.InitContainers[1].Name).To(Equal("iatric"))
		Expect(fetchedAutogenCron.Name).To(Equal(autogenName))
		Expect(fetchedAutogenCron.Spec.Schedule).To(Equal("20 * * 10 *"))
		Expect(fetchedAutogenCron.OwnerReferences[0].UID).To(Equal(fetched.UID))

		original := &pscv1alpha1.PreScaledCronJob{}
		Expect(k8sClient.Get(ctx, types.NamespacedName{Name: toCreate.Name, Namespace: namespace}, original)).Should(Succeed())

		By("Deleting the prescaled cron job CRD")
		Expect(k8sClient.Delete(ctx, original)).Should(Succeed())
		time.Sleep(time.Second * 30)

	})

	var _ = Describe("PrescaledCronJob Controller Unhappy Path", func() {

		const timeout = time.Second * 60
		const interval = time.Second * 1

		ctx := context.Background()

		Context("Invalid Cron Schedule", func() {
			It("Should create the psc but not a cron", func() {

				// construct a prescaled cron in code + post to K8s
				toCreate := generatePSCSpec()
				autogenName := autogenPrefix + toCreate.Name
				toCreate.Spec.CronJob.Spec.Schedule = "bananas"

				By("Creating the prescaled cron job CRD")
				Expect(k8sClient.Create(ctx, &toCreate)).Should(Succeed())
				time.Sleep(time.Second * 5)

				fetched := &pscv1alpha1.PreScaledCronJob{}

				// check the CRD was created and the controller hasn't crashed
				Eventually(func() bool {
					err := k8sClient.Get(ctx, types.NamespacedName{Name: toCreate.Name, Namespace: namespace}, fetched)
					return err == nil
				}, timeout, interval).Should(BeTrue())

				// should not have a downstream cron
				Eventually(func() bool {
					fetchedAutogenCron := &batchv1beta1.CronJob{}
					err := k8sClient.Get(ctx, types.NamespacedName{Name: autogenName, Namespace: namespace}, fetchedAutogenCron)
					return errors.IsNotFound(err)
				}, timeout, interval).Should(BeTrue())

			})
		})

		Context("Empty Cron Template", func() {
			It("Should reject the call", func() {

				// construct a prescaled cron in code + post to K8s
				toCreate := generatePSCSpec()
				toCreate.Spec.CronJob = batchv1beta1.CronJob{}

				By("Creating the prescaled cron job CRD")
				Expect(k8sClient.Create(ctx, &toCreate)).ShouldNot(Succeed())

			})
		})

		Context("Duplicate", func() {
			It("Should reject the create", func() {
				// construct a prescaled cron in code + post to K8s
				toCreate := generatePSCSpec()

				By("Posting the initial psc")
				Expect(k8sClient.Create(ctx, &toCreate)).Should(Succeed())

				By("Posting the duplicate")
				Expect(k8sClient.Create(ctx, &toCreate)).ShouldNot(Succeed())
			})
		})

		Context("Existing cron with same name", func() {
			It("Should not overwrite existing cron", func() {
				// construct a prescaled cron in code + post to K8s
				toCreate := generatePSCSpec()

				// post a manual cron object
				cron := toCreate.Spec.CronJob.DeepCopy()
				autogenName := autogenPrefix + toCreate.Name
				cron.Name = autogenName
				cron.Namespace = namespace

				Expect(k8sClient.Create(ctx, cron)).Should(Succeed())

				// now post the psc
				Expect(k8sClient.Create(ctx, &toCreate)).Should(Succeed())

				// wait a few
				time.Sleep(time.Second * 5)

				// check the original cronjob has its previous schedule and not been overwritten
				fetchedAutogenCron := &batchv1beta1.CronJob{}
				Eventually(func() bool {
					err := k8sClient.Get(ctx, types.NamespacedName{Name: autogenName, Namespace: namespace}, fetchedAutogenCron)
					return err == nil
				}, timeout, interval).Should(BeTrue())

				Expect(fetchedAutogenCron.Spec.Schedule).To(Equal("30 * * 10 *"))
			})
		})
	})
})

func generatePSCSpec() pscv1alpha1.PreScaledCronJob {

	spec := pscv1alpha1.PreScaledCronJobSpec{
		WarmUpTimeMins: 10,
		CronJob: batchv1beta1.CronJob{
			ObjectMeta: metav1.ObjectMeta{
				Name: "my-name-will-change",
			},
			Spec: batchv1beta1.CronJobSpec{
				Schedule: "30 * * 10 *",
				JobTemplate: batchv1beta1.JobTemplateSpec{
					Spec: batchv1.JobSpec{
						Template: v1.PodTemplateSpec{
							Spec: v1.PodSpec{
								Containers: []v1.Container{
									{
										Image: "busybox",
										Name:  "test-busybox",
										Args: []string{
											"/bin/sh",
											"-c",
											"date; sleep 90s; date;",
										},
										// Uncomment below when testing against a real cluster, to force some scaling
										//Resources: v1.ResourceRequirements{
										//	Requests: v1.ResourceList{
										//		"memory": resource.MustParse("1Gi"),
										//		"cpu":    resource.MustParse("1"),
										//	},
										//},
									},
								},
								RestartPolicy:  "OnFailure",
								InitContainers: []v1.Container{},
							},
						},
					},
				},
			},
		},
	}

	toCreate := pscv1alpha1.PreScaledCronJob{
		ObjectMeta: metav1.ObjectMeta{
			Name:      namePrefix + randString(),
			Namespace: namespace,
		},
		Spec: spec,
	}

	return toCreate
}

func randString() string {
	rand.Seed(time.Now().UnixNano())
	chars := []rune("abcdefghijklmnopqrstuvwxyz")
	length := 6
	var b strings.Builder
	for i := 0; i < length; i++ {
		b.WriteRune(chars[rand.Intn(len(chars))])
	}
	return b.String()
}
